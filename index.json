[{"uri":"/callToAction.html","title":"Call To Action","content":"\n# Call to Action\n\n## How to contribute\n\n*Imposter syndrome disclaimer*: I want your help. No really, I do.\n\nThere might be a little voice inside that tells you you're not ready; that you need to do one more tutorial, or learn another framework, or write a few more blog posts before you can help me with this project.\n\nI assure you, that's not the case.\n\nAll Ionide projects have some clear Contribution Guidelines and expectations that you can find in every repo - [example here](https://github.com/ionide/ionide-vscode-fsharp/blob/master/CONTRIBUTING.md).\n\nThe contribution guidelines outline the process that you'll need to follow to get a patch merged. By making expectations and processes explicit, I hope it will make it easier for you to contribute.\n\nAnd you don't just have to write code. You can help out by writing documentation, tests, or even by giving feedback about this work. (And yes, that includes giving feedback about the contribution guidelines.)\n\nThank you for contributing!\n\n## Contributing and copyright\n\nAll Ionide projects are hosted on [GitHub](https://github.com/ionide) where you can report issues, fork the project and submit pull requests.\n\nAll projects are avaliable available under an OSS license ([usually MIT](https://github.com/ionide/ionide-vscode-fsharp/blob/master/LICENSE.md)), which allows modification and redistribution for both commercial and non-commercial purposes.\n\nPlease note that all Ionide projects are released with a [Contributor Code of Conduct](https://github.com/ionide/ionide-vscode-fsharp/blob/master/CODE_OF_CONDUCT.md). By participating in this project you agree to abide by its terms.\n"},{"uri":"/sponsors.html","title":"Sponsors","content":"\n# Our Sponsors\n\nIonide couldn't be created without the support of [Lambda Factory](https://lambdafactory.io). If your company would be interested in supporting development of Ionide, or acquiring commercial support send us an email - lambda_factory@outlook.com.\n\nYou can also support Ionide development on [Open Collective](https://opencollective.com/ionide). [![Open Collective](https://opencollective.com/ionide/donate/button.png?color=blue)](https://opencollective.com/ionide)\n\n### Partners\n\n<div align=\"center\">\n\n<a href=\"https://lambdafactory.io\"><img src=\"https://cdn-images-1.medium.com/max/332/1*la7_YvDFvrtA720P5bYWBQ@2x.png\" alt=\"drawing\" width=\"100\"/></a>\n\n</div>\n\n### Sponsors\n\n[Become a sponsor](https://opencollective.com/ionide) and get your logo on our README on Github, description in the VSCode marketplace and on [ionide.io](http://ionide.io) with a link to your site.\n\n<div align=\"center\">\n    <object type=\"image/svg+xml\" data=\"https://opencollective.com/ionide/tiers/silver-sponsor.svg?avatarHeight=120&width=1000&button=false\"></object>\n    <br/>\n    <object type=\"image/svg+xml\" data=\"https://opencollective.com/ionide/tiers/bronze-sponsor.svg?avatarHeight=70&width=1000&button=false\"></object>\n</div>\n"},{"uri":"/index.html","title":"Home","content":"\n# Ionide\n\n<img heigh=\"100\" width=\"100\" src=\"static/images/logo.png\" />\n\nIonide is an organization which builds **high quality, cross platform developer tools for F#**. Our flagship project is Ionide-VSCode - a Visual Studio Code plugin, with more than 1 million downloads, transforming VSCode into a **fully-fledged F# IDE**. But Ionide is more than just an editor plugin - we build a whole ecosystem of developer tools - from a [documentation generator](Tools/fornax.html), to an [F# LSP server](Tools/fsac.html), to experimental and innovative projects like [F# Analyzers](Libraries/fsanalyzers.html).\n\n<img class=\"gif\" src=\"static/images/fsharp.gif\" />\n\n\n### Our goals and motivations\n\n> We build cross platform, F# developer tooling\n\n* Provide cross platform, open source developer tooling for F#\n* Provide a high quality IDE experience\n* Innovate in the area of development tooling for F# / FP languages\n* Provide a set of opinionated tools that work well together\n* Focus on UX, everything should Just Workâ„¢\n* Contribute to the general F# OSS ecosystem\n\n"},{"uri":"/Tools/fsac.html","title":"FsAutoComplete","content":"\n# FsAutoComplete\n\n**GitHub link:** [https://github.com/fsharp/FsAutoComplete](https://github.com/fsharp/FsAutoComplete)\n**License:** [Apache 2.0](https://github.com/fsharp/FsAutoComplete/blob/master/LICENSE)\n\nThe `FsAutoComplete` project (`FSAC`) provides a backend service for rich editing or intellisense features for editors.\nIt can be hosted using the [Language Server Protocol](https://microsoft.github.io/language-server-protocol/).\n\nCurrently it is used by:\n\n* [Emacs](https://github.com/fsharp/emacs-fsharp-mode)\n* [Vim](https://github.com/fsharp/vim-fsharp)\n* [Visual Studio Code](https://github.com/ionide/ionide-vscode-fsharp)\n\nIt's based on:\n\n* [FSharp.Compiler.Service](https://github.com/fsharp/FSharp.Compiler.Service/) for F# language info.\n* [FSharpLint](https://github.com/fsprojects/FSharpLint/) for the linter feature.\n* [Fantomas](https://github.com/fsprojects/fantomas) for the formatting feature.\n* [Dotnet.ProjInfo](Tools/dpi.html) for project/solution management.\n* [FSharp.Analyzers.SDK](/Libraries/fsanalyzers.html) for custom project based analyzers\n\n## Required software\n\nFsAutoComplete runs on modern .NET (formerly .NET Core).\n\n* .NET SDK (Required: >= 6.0)\n\n## Communication protocol\n\nFsAutoComplete supports [LSP](https://microsoft.github.io/language-server-protocol/) as a communication protocol.\n\n### Supported LSP endpoints\n\n* `initialize`\n* `textDocument/didOpen`\n* `textDocument/didChange`\n* `textDocument/didSave`\n* `textDocument/hover`\n* `textDocument/completion` & `completionItem/resolve`\n* `textDocument/rename`\n* `textDocument/definition`\n* `textDocument/typeDefinition`\n* `textDocument/implementation`\n* `textDocument/codeAction`:\n  * Remove unused `open`\n  * Resolve namespace/module\n  * Replace unused symbol with `_`\n  * Fix typo based on error message\n  * Remove redundant qualifier\n  * Add missing `new` keyword for `IDisposable`\n  * Generate cases for all DU case in pattern matching\n  * Generate empty interface implementation\n  * Fixes suggested by [FSharpLint](https://github.com/fsprojects/FSharpLint)\n* `textDocument/codeLens` & `codeLens/resolve`:\n  * signature Code Lenses\n  * reference number Code Lenses\n* `textDocument/formatting` - powered by [fantomas](https://github.com/fsprojects/fantomas)\n* `textDocument/references`\n* `textDocument/documentHighlight`\n* `textDocument/signatureHelp`\n* `textDocument/documentSymbol`\n* `workspace/didChangeWatchedFiles`\n* `workspace/didChangeConfiguration`\n* `workspace/symbol`\n\n### Custom endpoints\n\nCustom endpoints are using (for messages body) `PlainNotification` type and string format serialized with exactly same serialization format as old JSON protocol\n\n* `fsharp/signature` - accepts `TextDocumentPositionParams`, returns signature of symbol at given position as a formatted string\n* `fsharp/signatureData` - accepts `TextDocumentPositionParams`, returns signature of symbol at given position as DTO\n* `fsharp/lineLens` - accepts `ProjectParms` (`Project` filed contain F# file path), returns locations where LineLenses should be displayed\n* `fsharp/compilerLocation` - no input, returns paths to FCS, FSI and MsBuild\n* `fsharp/compile` - accepts `ProjectParms`, tries to compile project, returns list of errors and exit status code\n* `fsharp/workspacePeek` - accepts `WorkspacePeekRequest`, returns list of possible workspaces (resolved solution files, or list of projects if there are no solution files)\n* `fsharp/workspaceLoad` - accepts `WorkspaceLoadParms`, loads given list of projects in the background, partial result notified by `fsharp/notifyWorkspace` notification\n* `fsharp/project` - accepts `ProjectParms`, loads given project\n* `fsharp/fsdn` - accepts `ProjectParms` (`Project` filed contain query string), query FSDN and returns list of functions\n* `fsharp/f1Help` - accepts `TextDocumentPositionParams`, returns URL to MSDN documentation for symbol at given position\n* `fsharp/documentation` - accepts `TextDocumentPositionParams`, returns documentation data about symbol at given position, used for InfoPanel\n* `fsharp/documentationSymbol` - accepts `DocumentationForSymbolReuqest`, returns documentation data about given symbol from given assembly, used for InfoPanel\n\n### Supported LSP notifications\n\n* `window/showMessage`\n* `window/logMessage`\n* `textDocument/publishDiagnostics`\n\n### Custom notifications\n\n* `fsharp/notifyWorkspace` - notification for workspace/solution/project loading events\n* `fsharp/notifyWorkspacePeek` - notification for initial workspace peek\n\n### Additional startup options\n\n* `--background-service-enabled` - passing this flag enables background service feature, increasing FSAC responsiveness by moving some of the operations (especially background type checking) to other process. It results in increased memory usage. Used by default in Ionide.\n* `--verbose` - passing this flag enables additional logging being printed out in `stderr`\n* `DOTNET_ROOT` - setting this environment variable will set the dotnet SDK root, which is used when finding references for FSX scripts.\n\n### Initialization options\n\nOptions that should be send as `initializationOptions` as part of `initialize` request.\n\n* `AutomaticWorkspaceInit` - setting it to `true` will start Workspace Loading without need to run `fsharp/workspacePeek` and `fsharp/workspaceLoad` commands. It will always choose top workspace from the found list - all projects in workspace if 0 `.sln` files are found, `.sln` file if 1 `.sln` file was found, `.sln` file with most projects if multiple `.sln` files were found. It's designed to be used in clients that doesn't allow to create custom UI for selecting workspaces.\n\n### Settings\n\n* `FSharp.keywordsAutocomplete` - provides keywords in autocomplete list, recommended default value: `true`\n* `FSharp.ExternalAutocomplete` - provides autocomplete for symbols from not opened namespaces/modules, insert `open` on accept, recommended default value: `false`\n* `FSharp.Linter` - enables FSharpLint integration, provides additional warnings and code action fixes, recommended default value: `true`\n* `FSharp.UnionCaseStubGeneration` - enables code action to generate pattern matching cases, recommended default value: `true`\n* `FSharp.UnionCaseStubGenerationBody` - defines dummy body used by pattern matching generator, recommended default value: `\"failwith \\\"Not Implemented\\\"\"`\n* `FSharp.RecordStubGeneration` - enables code action to generate record stub, recommended default value: `true`\n* `FSharp.RecordStubGenerationBody` - defines dummy body used by record stub generator, recommended default value: `\"failwith \\\"Not Implemented\\\"\"`\n* `FSharp.InterfaceStubGeneration` - enables code action to generate interface stub, recommended default value: `true`\n* `FSharp.InterfaceStubGenerationObjectIdentifier` - defines object identifier used by interface stub generator,recommended default value: `\"this\"`\n* `FSharp.InterfaceStubGenerationMethodBody` - defines dummy body used by interface stub generator, recommended default value: `\"failwith \\\"Not Implemented\\\"\"`\n* `FSharp.UnusedOpensAnalyzer` - enables unused `open` detections, recommended default value: `true`\n* `FSharp.UnusedDeclarationsAnalyzer` - enables unused symbol detection, recommended default value: `true`\n* `FSharp.UseSdkScripts` - enables the use of .NET (Core) SDKs for script file type-checking and evaluation, otherwise the .NET Framework reference lists will be used. Current default and recommended value: `true`\n* `FSharp.SimplifyNameAnalyzer` - enables simplify name analyzer and remove redundant qualifier quick fix, recommended default value: `false`\n* `FSharp.ResolveNamespaces` - enables resolve namespace quick fix (add `open` if symbol is from not yet opened module/namespace), recommended default value: `true`\n* `FSharp.EnableReferenceCodeLens` - enables reference count code lenses, recommended default value: `true` if `--background-service-enabled` is used by default, `false` otherwise\n* `FSharp.dotNetRoot` - sets the root path for finding dotnet SDK references. Primarily used for FSX Scripts. Default value: operating-system dependent. On windows, `C:\\Program Files\\dotnet`; on Unix, `/usr/local/share/dotnet`\n* `FSharp.fsiExtraParameters` - an array of additional runtime arguments that are passed to FSI. These are used when typechecking scripts to ensure that typechecking has the same context as your FSI instances.  An example would be to set the following parameters to enable Preview features (like opening static classes) for typechecking."},{"uri":"/Tools/dpi.html","title":"dotnet-proj-info","content":"\n# dotnet-proj-info\n\n**GitHub link:** [https://github.com/ionide/dotnet-proj-info](https://github.com/ionide/dotnet-proj-info)\n**License:** [MIT](https://github.com/ionide/dotnet-proj-info/blob/master/LICENSE)\n\n`dotnet-proj-info` is library and command line tool used to parse and evaluate MsBuild files (`.fsproj`). It's used to get out of project files properties, list of files, list of project references, list of .NET references and more. It supports projects targeting both .NET Framework and .NET Core, using either old (verbose) project format or new (SDK-based) one. It's powering project cracking in [FsAutoComplete](/Tools/fsac.html) and solution explorer in [Ionide-VSCode](/Editors/Code/overview.html)\n\n### How to use\n\nInstall with:\n\n```bash\ndotnet tool install -g dotnet-proj\n```\n\nand\n\n```bash\ndotnet proj --help\n```\n\nUsage:\n\n```\ndotnet-proj.\n\nUSAGE: dotnet-proj [--help] [--verbose] [<subcommand> [<options>]]\n\nSUBCOMMANDS:\n\n    prop <options>        get properties\n    fsc-args <options>    get fsc arguments\n    csc-args <options>    get csc arguments\n    p2p <options>         get project references\n    net-fw <options>      list the installed .NET Frameworks\n    net-fw-ref <options>  get the reference path of given .NET Framework assembly\n\n    Use 'dotnet-proj <subcommand> --help' for additional information.\n\nOPTIONS:\n\n    --verbose, -v         verbose log\n    --help                display this list of options.\n```\n\nSubcommands support usual arguments of .NET cli (`dotnet`) where it makes sense, for example:\n\n- the target project\n- `-c` or `--configuration`\n- `-f` or `--framework`\n- `-r` or `--runtime`\n"},{"uri":"/Tools/fornax.html","title":"Fornax","content":"\n# Fornax\n\n**GitHub link:** [https://github.com/ionide/Fornax](https://github.com/ionide/Fornax)\n**License:** [MIT](https://github.com/ionide/Fornax/blob/master/LICENSE)\n\n\nFornax is a **scriptable static site generator** using type safe F# DSL to define page layouts. This documentation has been built using Fornax.\n\n## Installation\n\nFornax is released as a global .NET Core tool. You can install it with `dotnet tool install fornax -g`\n\n## CLI Application\n\nThe main functionality of Fornax comes from CLI applications that lets user scaffold, and generate webpages.\n\n* `fornax new` - scaffolds new blog in current working directory using really simple template\n* `fornax build` - builds webpage, puts output to `_public` folder\n* `fornax watch` - starts a small webserver that hosts your generated site, and a background process that recompiles the site whenever any changes are detected. This is the recommended way of working with Fornax.\n* `fornax clean` - removes output directory and any temp files\n* `fornax version` - prints out the currently-installed version of Fornax\n* `fornax help` - prints out help\n\n## Getting started\n\nEasiest way to get started with `fornax` is running `fornax new` and than `fornax watch` - this will create fairly minimal blog site template, start `fornax` in watch mode and start webserver. Then you can go to the `localhost:8080` in your browser to see the page, and edit the scaffolded files in editor to make changes.\nAdditionally, you can take a look at `samples` folder in this repository - it have couple more `loaders` and `generators` that you can potentially use in your website.\n\n## Website definition\n\nFornax is using normal F# code (F# script files) to define any of it's core concepts: `loaders`, `generators` and `config`.\n\n### SiteContents\n\n`SiteContents` is fairly simple type that provides access to any information available to the Fornax. The information is put into it by using `loaders` and then can be accessed in the `generators`.\n\n`SiteContents` has several functions in it's public API:\n\n```fsharp\ntype A = {a: string}\ntype B = {b: int; c: int}\n\nlet sc = SiteContents()\nsc.Add({a = \"test\"})\nsc.Add({a = \"test2\"})\nsc.Add({a = \"test3\"})\n\nsc.Add({b = 1; c = 3}) //You can add objects of different types, `Add` method is generic.\n\nlet as = sc.TryGetValues<A>() //This will return option of sequence of all added elements for given type - in this case it will be 3 elements\nlet b = sc.TryGetValue<B>() //This will return option of element for given type\n```\n\n### Loaders\n\n`Loader` is an F# script responsible for loading external data into generation context. The data typically includes things like content of `.md` files, some global site configuration, etc. But since those are normal F# functions, you can do whatever you need.\nWant to load information from local database, or from internet? Sure, why not. Want to use World Bank TP to include some of the World Bank statistics? That's also possible - you can use in `loader` any dependency as in normal F# script.\n\n`Loaders` are normal F# functions that takes as an input `SiteContents` and absolute path to the page root, and returns `SiteContents`:\n\n```fsharp\n#r \"../_lib/Fornax.Core.dll\"\n\ntype Page = {\n    title: string\n    link: string\n}\n\nlet loader (projectRoot: string) (siteContent: SiteContents) =\n    siteContent.Add({title = \"Home\"; link = \"/\"})\n    siteContent.Add({title = \"About\"; link = \"/about.html\"})\n    siteContent.Add({title = \"Contact\"; link = \"/contact.html\"})\n\n    siteContent\n```\n\n**Important note**: You can (and probably should) define multiple loaders - they will all be executed before generation of site, and will propagate information into `SiteContents`\n\n### Generators\n\n`Generator` is an F# script responsible for generating output of the Fornax process. This is usually `.html` file, but can be anything else - actually `generator` API just requires to return `string` that will be saved to file. Generators are, again, plain F# functions that as an input takes `SiteContents`, absolute path to the page root, relative path to the file that's currently processed (may be empty for the global generators) and returns `string`:\n\n```fsharp\n#r \"../_lib/Fornax.Core.dll\"\n#if !FORNAX\n#load \"../loaders/postloader.fsx\"\n#endif\n\nopen Html\n\nlet generate' (ctx : SiteContents) (_: string) =\n    let posts = ctx.TryGetValues<Postloader.Post> () |> Option.defaultValue Seq.empty\n\n    let psts =\n        posts\n        |> Seq.toList\n        |> List.map (fun p -> span [] [!! p.link] )\n\n    html [] [\n        div [] psts\n    ]\n\nlet generate (ctx : SiteContents) (projectRoot: string) (page: string) =\n    generate' ctx page\n    |> HtmlElement.ToString\n```\n\n**Important note**: You can (and probably should) define multiple generators - they will generate different kinds of pages and/or content, such as `post`, `index`, `about`, `rss` etc.\n\n### Configuration\n\n`Configuration` is a F# script file that defines when which analyzers need to be run, and how to save its output. `Config.fsx` file needs to be put in the root of your site project (the place from which you run `fornax` CLI tool)\n\n```fsharp\n#r \"../_lib/Fornax.Core.dll\"\n\nopen Config\nopen System.IO\n\nlet postPredicate (projectRoot: string, page: string) =\n    let fileName = Path.Combine(projectRoot,page)\n    let ext = Path.GetExtension page\n    if ext = \".md\" then\n        let ctn = File.ReadAllText fileName\n        ctn.Contains(\"layout: post\")\n    else\n        false\n\nlet staticPredicate (projectRoot: string, page: string) =\n    let ext = Path.GetExtension page\n    if page.Contains \"_public\" ||\n       page.Contains \"_bin\" ||\n       page.Contains \"_lib\" ||\n       page.Contains \"_data\" ||\n       page.Contains \"_settings\" ||\n       page.Contains \"_config.yml\" ||\n       page.Contains \".sass-cache\" ||\n       page.Contains \".git\" ||\n       page.Contains \".ionide\" ||\n       ext = \".fsx\"\n    then\n        false\n    else\n        true\n\nlet config = {\n    Generators = [\n        {Script = \"less.fsx\"; Trigger = OnFileExt \".less\"; OutputFile = ChangeExtension \"css\" }\n        {Script = \"sass.fsx\"; Trigger = OnFileExt \".scss\"; OutputFile = ChangeExtension \"css\" }\n        {Script = \"post.fsx\"; Trigger = OnFilePredicate postPredicate; OutputFile = ChangeExtension \"html\" }\n        {Script = \"staticfile.fsx\"; Trigger = OnFilePredicate staticPredicate; OutputFile = SameFileName }\n        {Script = \"index.fsx\"; Trigger = Once; OutputFile = NewFileName \"index.html\" }\n\n    ]\n}\n\n```"},{"uri":"/Editors/editorsOverview.html","title":"Editors overview","content":"\n# Editors overview\n\nOne of the main goals of the Ionide initiative is providing rich, cross-platform, open-source IDEs for F#."},{"uri":"/Editors/index.html","title":"Index","content":""},{"uri":"/Libraries/fsanalyzers.html","title":"FSharp.Analyzers.SDK","content":"\n# FSharp.Analyzers.SDK\n\n**GitHub link:** [https://github.com/ionide/FSharp.Analyzers.SDK](https://github.com/ionide/FSharp.Analyzers.SDK)\n**License:** [MIT](https://github.com/ionide/FSharp.Analyzers.SDK/blob/master/LICENSE.md)\n\n`FSharp.Analyzers.SDK` is a library used for building custom analyzers for FSAC / F# editors. F# analyzers are live, real-time, project-based plugins that enables diagnosis of source code and surfacing of custom errors, warnings and code fixes into the editor. They're heavily influenced and inspired by [Roslyn Analyzers](https://docs.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview?view=vs-2019).\n\nRead more about F# Analyzers here - [https://medium.com/lambda-factory/introducing-f-analyzers-772487889429](https://medium.com/lambda-factory/introducing-f-analyzers-772487889429)\n\n## Writing Analyzers\n\nAnalyzers that are consumed by this SDK and from Ionide are simply .NET core class libraries. These class libraries expose a *value* of type `Analyzer` which is effectively a function that has input of type `Context` and returns a list of `Message` records:\n\n```fsharp\nmodule BadCodeAnalyzer\n\nopen FSharp.Analyzers.SDK\n\n[<Analyzer>]\nlet badCodeAnalyzer : Analyzer =\n  fun (context: Context) =\n    // inspect context to determine the error/warning messages\n    [   ]\n```\n\nNotice how we expose the function `BadCodeAnalyzer.badCodeAnalyzer` with an attribute `[<Analyzer>]` that allows the SDK to detect the function. The input `Context` is a record that contains information about a single F# file such as the typed AST, the AST, the file content, the file name and more. The SDK runs this function against all files of a project during editing. The output messages that come out of the function are eventually used by Ionide to highlight the inspected code as a warning or error depending on the `Severity` level of each message.\n\n### Analyzer Requirements\n\nAnalyzers are .NET Core class libraries and they are distributed as such. However, since the SDK relies on dynamically loading the analyzers during runtime, there are some requirements to get them to work properly:\n - The analyzer class library has to target the `net6.0` framework\n - The analyzer has to reference the latest `FSharp.Analyzers.SDK` (at least the version used by FsAutoComplete which is subsequently used by Ionide)\n\n### Packaging and Distribution\n\nSince analyzers are just .NET core libraries, you can distribute them to the nuget registry just like you would with a normal .NET package. Simply run `dotnet pack --configuration Release` against the analyzer project to get a nuget package and publish it with\n\n```\ndotnet nuget push {NugetPackageFullPath} -s nuget.org -k {NugetApiKey}\n```\n\nHowever, the story is different and slightly more complicated when your analyzer package has third-party dependencies also coming from nuget. Since the SDK dynamically loads the package assemblies (`.dll` files), the assemblies of the dependencies has be located *next* to the main assembly of the analyzer. Using `dotnet pack` will **not** include these dependencies into the output Nuget package. More specifically, the `./lib/net6.0` directory of the nuget package must have all the required assemblies, also those from third-party packages. In order to package the analyzer properly with all the assemblies, you need to take the output you get from running:\n\n```\ndotnet publish --configuration Release --framework net6.0\n```\n\nagainst the analyzer project and put every file from that output into the `./lib/net6.0` directory of the nuget package. This requires some manual work by unzipping the nuget package first (because it is just an archive), modifying the directories then zipping the package again. It can be done using a FAKE build target to automate the work:\n\n```fsharp\n// make ZipFile available\n#r \"System.IO.Compression.FileSystem.dll\"\n\nlet releaseNotes = ReleaseNotes.load \"RELEASE_NOTES.md\"\n\nTarget.create \"PackAnalyzer\" (fun _ ->\n    let analyzerProject = \"src\" </> \"BadCodeAnalyzer\"\n    let args =\n        [\n            \"pack\"\n            \"--configuration Release\"\n            sprintf \"/p:PackageVersion=%s\" releaseNotes.NugetVersion\n            sprintf \"/p:PackageReleaseNotes=\\\"%s\\\"\" (String.concat \"\\n\" releaseNotes.Notes)\n            sprintf \"--output %s\" (__SOURCE_DIRECTORY__ </> \"dist\")\n        ]\n\n    // create initial nuget package\n    let exitCode = Shell.Exec(\"dotnet\", String.concat \" \" args, analyzerProject)\n    if exitCode <> 0 then\n        failwith \"dotnet pack failed\"\n    else\n        match Shell.Exec(\"dotnet\", \"publish --configuration Release --framework net6.0\", analyzerProject) with\n        | 0 ->\n            let nupkg =\n                System.IO.Directory.GetFiles(__SOURCE_DIRECTORY__ </> \"dist\")\n                |> Seq.head\n                |> IO.Path.GetFullPath\n\n            let nugetParent = DirectoryInfo(nupkg).Parent.FullName\n            let nugetFileName = IO.Path.GetFileNameWithoutExtension(nupkg)\n\n            let publishPath = analyzerProject </> \"bin\" </> \"Release\" </> \"net6.0\" </> \"publish\"\n            // Unzip the nuget\n            ZipFile.ExtractToDirectory(nupkg, nugetParent </> nugetFileName)\n            // delete the initial nuget package\n            File.Delete nupkg\n            // remove stuff from ./lib/net6.0\n            Shell.deleteDir (nugetParent </> nugetFileName </> \"lib\" </> \"net6.0\")\n            // move the output of publish folder into the ./lib/net6.0 directory\n            Shell.copyDir (nugetParent </> nugetFileName </> \"lib\" </> \"net6.0\") publishPath (fun _ -> true)\n            // re-create the nuget package\n            ZipFile.CreateFromDirectory(nugetParent </> nugetFileName, nupkg)\n            // delete intermediate directory\n            Shell.deleteDir(nugetParent </> nugetFileName)\n        | _ ->\n            failwith \"dotnet publish failed\"\n)\n```\n"},{"uri":"/Libraries/waypoint.html","title":"Waypoint","content":"\n# Waypoint\n\n**GitHub link:** [https://github.com/ionide/Waypoint](https://github.com/ionide/Waypoint)\n**License:** [MIT](https://github.com/ionide/Waypoint/blob/master/LICENSE.md)\n\nOpinionated solution template for building F# OSS libraries and tools.\n\nSample repository is available here - https://github.com/Krzysztof-Cieslak/SampleWaypoint\n\nSample generated documentation can be found here - http://kcieslak.io/SampleWaypoint\n\n## What's included in template\n\n* Paket, FAKE, and Fornax added as `dotnet` local tools (`.config/dotnet-tools.json`)\n* `build.fsx` file, containing default FAKE script with targets for building, testing, documentation generation, publishing to GitHub, and publishing to NuGet\n* `paket.dependencies` with basic set of dependencies\n* `src` folder containing 2 projects - one class library (`netstandard2.0`), and CLI tool (`netcoreapp3.1`)\n* `test` folder containing UnitTest project using Expecto and FsCheck\n* `docs` folder with Fornax documentation template that will generate nice documentation for your project.\n* `.devcontainer` folder with definition of [Development Container](https://code.visualstudio.com/docs/remote/containers)\n* `.github/workflows` folder with definition for 2 GitHub actions - one for building and testing code as CI, one for deploying documentation when new tag is pushed. To use latter, you need to define `PERSONAL_TOKEN` secret in GitHub repo settings with Personal Access Token.\n* `.github/ISSUE_TEMPLATE` folder with 2 different issue templates - one for bug report, other one for feature request\n\n## Documentation Theme\n\nTemplate includes, out-of-the-box, nice theme for your project documentation, which integrates with FSharp.Formatting to create also API reference\n\n* Sample documentation produced by the template can be found on http://kcieslak.io/SampleWaypoint.\n* Created theme is partial port to Fornax of [Hugo Learn theme](https://learn.netlify.com/en/).\n* You define content as markdown files\n* Support for unlimited multi-level navigation\n* Use FSharp.Formatting to create API reference for the project - sample: http://kcieslak.io/SampleWaypoint/Reference/ApiRef.html\n* Use [Lunr.js](https://lunrjs.com/) to provide client side search based on generated by Fornax search index - sample: try searching for `Lorem` or `Sample` in search available on http://kcieslak.io/SampleWaypoint\n* Use [Mermaid.js](https://mermaid-js.github.io/mermaid/#/) to provide client side render diagrams and graphs - sample: http://kcieslak.io/SampleWaypoint/diagrams.html\n\n## How to use template\n\n1. Install `dotnet new` template with `dotnet new -i Waypoint`\n2. Create new folder `mkdir TestApp` and go into it `cd TestApp`\n3. Create new project with `dotnet new Waypoint`\n\n## Motivation\n\nWaypoint got created for couple of reasons. Mostly because I (Chris) was unhappy with possible options \"on the market\" - don't get me wrong, I think projects like MiniScaffold are doing great job, but it was just not hitting my personal sweet spot for what I wanted from project scaffold.\nSecondly I strongly believe into having opinionated set of tools working well together, providing great Developer Experience - building such tools is something I've been doing for last couple of years, so providing single \"package\" seems like a logical next step.\nThirdly, I want Waypoint to be \"canonical\" example of using Fornax for documentation generation - scaffolded template contains really nice theme for documentation, integration with FSharp.Formatting, built-in search support, and more.\n\n\n## Inspired by\n\nNo project lives in vacuum - good ideas are very often just small improvements on the previous state of art. Waypoint has been heavily inspired by:\n\n* [fsprojects/ProjectScaffold](https://github.com/fsprojects/ProjectScaffold) - original F# OSS project template used by countless projects in F# ecosystem\n* [TheAngryByrd/MiniScaffold](https://github.com/TheAngryByrd/MiniScaffold) - great project scaffold created by @TheAngryByrd, having many different options and functionalities\n* [SAFE-Stack/SAFE-template](https://github.com/SAFE-Stack/SAFE-template) - SAFE Stack template by @theimowski\n\n## Used projects\n\n* [.NET SDK](https://dotnet.microsoft.com/download) - modern, OSS, cross platform distribution of .NET; `dotnet` - CLI tool for developers\n* [Paket](https://fsprojects.github.io/Paket/) - Paket is a dependency manager for .NET projects, popular in F# community.\n* [FAKE](https://fake.build/) - F# build DSL and task runner\n* [Fornax](https://ionide.io/Tools/fornax.html) - scriptable static site generator using type safe F# DSL to define page layouts\n* [Expecto](https://github.com/haf/expecto) - F# test library\n* [FsCheck](https://github.com/fscheck/FsCheck) - Random testing library for F#\n\n## FAQ\n\n1. What about `fsprojects/ProjectScaffold` ?\n\nProjectScaffold is fairly outdated template, and I think everyone, including original creators of ProjectScaffold will welcome modern alternative.\n\n2. What about `TheAngryByrd/MiniScaffold` ?\n\nMiniScaffold is great project, with many options and functionalities - such as code formatting, test coverage, sourcelinks and more. I've decided to create a scaffold feeding my needs and needs of Ionide projects that's bit more opinionated, and provide less functionalities. Please use whichever scaffold you want!\n\n3. Why do we even need solution scaffold? Is `dotnet new console` and `dotnet build` not enough?\n\nNo, it's not enough. Real world project, unlike conference demos, requires more structure, testing, documentation - especially OSS projects, if you care for adaption and user happiness. Beacuse of that we need something that will provide nice experience for both users and developers of the OSS projects.\n"},{"uri":"/Libraries/eventhorizon.html","title":"Ionide.EventHorizon","content":"\n# Ionide.EventHorizon\n\n**GitHub link:** [https://github.com/ionide/FSharp.EventHorizon](https://github.com/ionide/FSharp.EventHorizon)\n**License:** [MIT](https://github.com/ionide/FSharp.EventHorizon/blob/master/LICENSE.md)\n\nAn **experiment** attempting to implement `type holes` and `type-directed search`/`valid hole fits` using F# analyzers. Long story short, it's an attempt at suggesting replacements for  unknown functions using type inference, as well as finding other entities that have matching type signatures.\n\n- Read more about `type holes`: [https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/typed-holes.html](https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/typed-holes.html)\n- Read more about `type-directed search` in PureScript: [https://github.com/paf31/24-days-of-purescript-2016/blob/master/23.markdown](https://github.com/paf31/24-days-of-purescript-2016/blob/master/23.markdown)\n- Read more about `valid hole fits` in GHC: [https://mpg.is/papers/gissurarson2018suggesting.pdf](https://mpg.is/papers/gissurarson2018suggesting.pdf)\n\nUnlike some of the solutions for other FP languages, this is not a feature implemented directly in compiler, nor is it a feature of any particular IDE; rather it's using F# Analyzers.\n\nRead more about F# Analyzers:\n  - Intro blog post - [https://medium.com/lambda-factory/introducing-f-analyzers-772487889429](https://medium.com/lambda-factory/introducing-f-analyzers-772487889429)\n  - FSharp.Analyzers.SDK repo - [https://github.com/ionide/FSharp.Analyzers.SDK](https://github.com/ionide/FSharp.Analyzers.SDK)\n  - Sample analyzer implementation - [https://github.com/Krzysztof-Cieslak/FSharp.Analyzers.Sample](https://github.com/Krzysztof-Cieslak/FSharp.Analyzers.Sample)\n  - Sample repo showing how to use analyzers - [https://github.com/Krzysztof-Cieslak/AnalyzersShowcase](https://github.com/Krzysztof-Cieslak/AnalyzersShowcase)\n\n<img class=\"gif\" src=\"/static/images/EventHorizon.png\" />\n\n## Limitations\n\nF# Compiler Service does not expose any API for `subsumption of types`. I've implemented a really naive algorithm to check if an entity can fit a given type hole... but well, it's definitely not following the rules of the F# compiler 100%, so not every suggestion is found.\n\nI think that this limitation is acceptable given that the project is in an experimental phase - if it were productized, we would need to expose those missing APIs from F# Compiler Services, so investing more into a custom algorithm here would be a waste of time.\n"},{"uri":"/Editors/Vim/getting_started.html","title":"Installation","content":"\n# Ionide-vim - Installation\n\n## Requirements\n\n* Neovim or Vim 8.0+ - Python support is not required as of now. This may or may not change in the future.\n* [.NET SDK](https://dotnet.microsoft.com/download) - required to run FsAutoComplete\n* [LanguageClient-neovim](https://github.com/autozimu/LanguageClient-neovim) - LSP client used to communicate with FsAutoComplete\n* [fzf](https://github.com/junegunn/fzf) (optional) -Optional dependency of LanguageClient-neovim, provides multi-entry selection UI\n\n## Getting Started\n\n### 1. Install [LanguageClient-neovim](https://github.com/autozimu/LanguageClient-neovim)\n\nRefer to [their INSTALL.md](https://github.com/autozimu/LanguageClient-neovim/blob/next/INSTALL.md).\n\n### 2. Install Ionide-vim\n\n#### Installing with your plugin manager\n\n##### [vim-plug](https://github.com/junegunn/vim-plug)\n\n~~~.vim\nPlug 'ionide/Ionide-vim', {\n      \\ 'do':  'make fsautocomplete',\n      \\}\n~~~\n\n##### [dein.vim](https://github.com/Shougo/dein.vim)\n\n~~~.vim\ncall dein#add('ionide/Ionide-vim', {\n    \\ 'build': 'make fsautocomplete',\n    \\ })\n~~~\n\n#### Installing manually\n\nClone Ionide-vim to some runtimepath and run `make fsautocomplete`.\n\n#### Installing on Windows\n\nRun `install.cmd`."},{"uri":"/Editors/Vim/overview.html","title":"Overview","content":"\n# Ionide-vim\n\n**GitHub link:** [https://github.com/ionide/Ionide-vim](https://github.com/ionide/Ionide-vim)\n**License:** [MIT](https://github.com/ionide/Ionide-vim/blob/master/LICENSE.md)\n\nIonide-vim is a F# plugin for Vim/Neovim. It's continuation of [fsharp/vim-fsharp](https://github.com/fsharp/vim-fsharp), powered by LSP protocol using [FsAutoComplete](/Tools/fsac.html). On the client side, it's powered by [autozimu/LanguageClient-neovim](https://github.com/autozimu/LanguageClient-neovim)\n\n\n<img class=\"gif\" src=\"/static/images/vim.gif\" />\n\n## List of features\n\n- Syntax highlighting\n- Auto completions\n- Error highlighting, error list, and quick fixes based on errors\n- Tooltips\n- Go to Definition\n- Find all references\n- Highlighting usages\n- Rename\n- Show symbols in file\n- Find symbol in workspace\n- Show signature in status line\n- Integration with F# Interactive **(new!)**\n- Integration with FSharpLint (additional hints and quick fixes) **(new!)**\n\n\n\n"},{"uri":"/Editors/Vim/usage.html","title":"How to use","content":"\n# How to use\n\nOpening either `*.fs`, `*.fsi` or `*.fsx` files should trigger syntax highlighting and other depending runtime files as well.\n\n### Commands\n\nRefer to [LanguageClient-neovim](https://github.com/autozimu/LanguageClient-neovim) for features provided via Language Server Protocol.\n\nTo be added as requested for F#-specific features.\n\n#### `:FSharpLoadWorkspaceAuto`\n  - Searches a workspace (`sln` or `fsproj`) and then load it.\n  - Equivalent to `FSharp.workspaceMode = sln` in Ionide-VSCode.\n  - Automatically called when you open F# files. Can be disabled in settings.\n  - The deep level of directory hierarchy to search can also be configured in settings.\n\n#### `:FSharpParseProject <files>+`\n  - Loads specified projects (`sln` or `fsproj`).\n\n#### `:FSharpReloadWorkspace`\n  - Reloads all the projects currently loaded.\n  - Automatically called when you save `.fsproj` files. Can be disabled in settings.\n\n#### `:FSharpUpdateServerConfig`\n  - Updates FSAC configuration.\n  - See [FsAutoComplete Settings](#fsautocomplete-settings) for details.\n\n#### `:FSharpUpdateFSAC`\n  - Downloads the latest build of FsAutoComplete to be used with Ionide-vim.\n\n### Working with F# Interactive\n\nIonide-vim has an integration with F# Interactive.\n\nFSI is displayed using the builtin `:terminal` feature introduced in Vim 8 / Neovim and can be used like in VSCode.\n\n#### `:FsiShow`\n  - Shows a F# Interactive window.\n\n#### `:FsiEval <expr>`\n  - Evaluates given expression in FSI.\n\n#### `:FsiEvalBuffer`\n  - Sends the content of current file to FSI.\n\n#### `:FsiReset`\n  - Resets the current FSI session.\n\n#### `Alt-Enter`\n  - When in normal mode, sends the current line to FSI.\n  - When in visual mode, sends the selection to FSI.\n  - Sending code to FSI opens FSI window but the cursor does not focus to it. Unlike Neovim, Vim doesn't support asynchronous buffer updating so you have to input something (e.g. moving cursor) to see the result. You can change this behavior in settings.\n\n#### `Alt-@`\n  - Toggles FSI window. FSI windows shown in different tabpages share the same FSI session.\n  - When opened, the cursor automatically focuses to the FSI window (unlike in `Alt-Enter` by default).\n\nYou can customize the location of FSI, key mappings, etc. See [the documentation below](#f-interactive-settings).\n\n### Settings\n\nRefer to [LanguageClient-neovim's recommended settings](https://github.com/autozimu/LanguageClient-neovim/wiki/Recommended-Settings#recommended-settings)\nfor features provided via Language Server Protocol.\n\nTo be added as requested for F#-specific features.\n\n#### FsAutoComplete Settings\n\n* Ionide-vim uses `snake_case` for the setting names.\n  - For FSAC settings only, `CamelCase` can also be used (as it gets serialized to a F# record).\n  - If both `snake_case` and `CamelCase` are specified, the `snake_case` one will be preferred.\n* You can change the values at runtime and then notify the changes to FSAC by `:FSharpUpdateServerConfig`.\n* Some of the settings may not work in Ionide-vim as it is lacking the corresponding feature of Ionide-VSCode.\n* If not specified, the recommended default values described on the FSAC's documentation will be used.\n  - If you are using a JSON configuration file though `g:LanguageClient_settingsPath`, the recommended default values will override the settings loaded from it.\n  - You can disable this by `let g:fsharp#use_recommended_server_config = 0`.\n\nSee [the documentation of FSAC](https://github.com/fsharp/FsAutoComplete#settings)\nfor the complete list of available settings. Frequently used ones are:\n\n##### Enable/disable automatic calling of `:FSharpLoadWorkspaceAuto` on opening F# files (default: enabled)\n\n~~~.vim\nlet g:fsharp#automatic_workspace_init = 1 \" 0 to disable.\n~~~\n\n##### Set the deep level of directory hierarchy when searching for sln/fsprojs (default: `2`)\n\n~~~.vim\nlet g:fsharp#workspace_mode_peek_deep_level = 2\n~~~\n\n##### Ignore specific directories when loading a workspace (default: empty)\n\n~~~.vim\nlet g:fsharp#exclude_project_directories = ['paket-files']\n~~~\n\n##### Enable/disable linter and unused opens/declarations analyzer (default: all enabled)\n\nYou may want to bind `LanguageClient#textDocument_codeAction()` to some shortcut key. Refer to their docs.\n\n~~~.vim\n\" 0 to disable.\nlet g:fsharp#linter = 1\nlet g:fsharp#unused_opens_analyzer = 1\nlet g:fsharp#unused_declarations_analyzer = 1\n~~~\n\n#### Editor Settings\n\n##### Enable/disable automatic calling of `:FSharpReloadWorkspace` on saving `fsproj` (default: enabled)\n\n~~~.vim\nlet g:fsharp#automatic_reload_workspace = 1 \" 0 to disable.\n~~~\n\n##### Show type signature at cursor position (default: enabled)\n\n~~~.vim\nlet g:fsharp#show_signature_on_cursor_move = 1 \" 0 to disable.\n~~~\n\n#### F# Interactive Settings\n\n##### Change the F# Interactive command to be used within Ionide-vim (default: `dotnet fsi`)\n\nIf you want to use a .NET Framework FSI instead of .NET Core one, set `g:fsharp#use_sdk_scripts` to `0`.\nSee: https://github.com/fsharp/FsAutoComplete/pull/466#issue-324869672\n\n~~~.vim\nlet g:fsharp#fsi_command = \"fsharpi\"\nlet g:fsharp#use_sdk_scripts = 0 \" for net462 FSI\n~~~\n\n##### Set additional runtime arguments passed to FSI (default: `[]` (empty))\n\nSets additional arguments of the FSI instance Ionide-vim spawns and changes the behavior of FSAC accordingly when editing fsx files.\n\n~~~.vim\nlet g:fsharp#fsi_extra_parameters = ['--langversion:preview']\n~~~\n\n##### Customize how FSI window is opened (default: `botright 10new`)\n\nIt must create a new empty window and then focus to it.\n\nSee [`:help opening-window`](http://vimdoc.sourceforge.net/htmldoc/windows.html#opening-window) for details.\n\n~~~.vim\nlet g:fsharp#fsi_window_command = \"botright vnew\"\n~~~\n\n##### Set if sending line/selection to FSI shoule make the cursor focus to FSI window (default: disabled)\n\nIf you are using Vim, you might want to enable this to see the result without inputting something.\n\n~~~.vim\nlet g:fsharp#fsi_focus_on_send = 1 \" 0 to not to focus.\n~~~\n\n##### Change the key mappings (default: `vscode`)\n\n* `vscode`:     Default. Same as in Ionide-VSCode (`Alt-Enter` to send, `Alt-@` to toggle terminal).\n  - `<M-CR>` in Neovim / `<ESC><CR>` in Vim: Sends line/selection to FSI.\n  - `<M-@>`  in Neovim / `<ESC>@`    in Vim: Toggles FSI window.\n* `vim-fsharp`: Same as in [fsharp/vim-fsharp](https://github.com/fsharp/vim-fsharp#fsharp-interactive). Note that `<leader>` is mapped to backslash by default. See [`:help mapleader`](http://vimdoc.sourceforge.net/htmldoc/map.html#mapleader).\n  - `<leader>i` : Sends line/selecion to FSI.\n  - `<leader>e` : Toggles FSI window.\n* `custom`:     You must set both `g:fsharp#fsi_keymap_send` and `g:fsharp#fsi_keymap_toggle` by yourself.\n  - `g:fsharp#fsi_keymap_send`   : Sends line/selection to FSI.\n  - `g:fsharp#fsi_keymap_toggle` : Toggles FSI window.\n* `none`:       Disables mapping.\n\n~~~.vim\n\" custom mapping example\nlet g:fsharp#fsi_keymap = \"custom\"\nlet g:fsharp#fsi_keymap_send   = \"<C-e>\"\nlet g:fsharp#fsi_keymap_toggle = \"<C-@>\"\n~~~\n\n### Advanced Tips\n\n#### Show tooltips on CursorHold\n\nIf you are using neovim 0.4.0 or later, floating windows will be used for tooltips and you might find it convenient to make them appear if the cursor does not move for several seconds.\n\n~~~.vim\nif has('nvim') && exists('*nvim_open_win')\n  augroup FSharpShowTooltip\n    autocmd!\n    autocmd CursorHold *.fs,*.fsi,*.fsx call fsharp#showTooltip()\n  augroup END\nendif\n~~~\n\nNote that you can set the delay time to show the tooltip by [`set updatetime=<ms>`](http://vimdoc.sourceforge.net/htmldoc/options.html#'updatetime'). The default delay is 4 seconds, which you may find too slow."},{"uri":"/Editors/Code/getting_started.html","title":"Getting started","content":"\n# Getting started\n\n## Requirements\n\n* Visual Studio Code - it is a lightweight but powerful source code editor which runs on your desktop and is available for Windows, macOS and Linux created by Microsoft. For detailed documentation of editor, getting-started guides and more visit [official documentation](https://code.visualstudio.com/docs).\n\n* F# - it is a mature, open source, cross-platform, functional-first programming language. It empowers users and organizations to tackle complex computing problems with simple, maintainable and robust code. Ionide supports F# version 6.0. Detailed installation instructions can be found of F# Software foundation webpage - for [Windows](http://fsharp.org/use/windows/), [MacOS](http://fsharp.org/use/mac/), and [Linux](http://fsharp.org/use/linux/)\n\n* .NET SDK - .NET is lightweight, cross platform, modern implementation of .NET Framework. We strongly recommend installing it since some advanced Ionide features such as debugging and project scaffolding depends on SDK and `dotnet` CLI tooling even if your application is targetting Full Framework. For detailed instructions on installing .NET visit [official step-by-step installation guide](https://dotnet.microsoft.com/download)\n\n* VSCode C# plugin (optional) - Ionide's debugging capabilities relies on the debugger provided by Omnisharp team. To get it install [C# extension from VSCode marketplace](https://marketplace.visualstudio.com/items?itemName=ms-vscode.csharp)\n\n* MsBuild 2022 (Windows only, optional) - For old, verbose `.fsproj` files on Windows MsBuild 2022 (17.0) needs to be additionally installed. You can find it in the Tools for Visual Studio 2022 section [here](https://visualstudio.microsoft.com/downloads/) or install Visual Studio 2022 itself. However, we highly recommend using new, SDK-based project files.\n\n## Plugin installation\n\nAny VSCode extension can be installed using UI just inside VSCode. Bring up the Extensions view by clicking on the Extensions icon in the Activity Bar on the side of VS Code or the `View: Extensions` command (`Ctrl+Shift+X`). Then in search box type `Ionide` to find all 3 extensions we provide. Click the `Install` button and after a successful install, you'll see an `Reload` button which will prompt you to restart VS Code to enable the new extension. For more detailed information about plugin installation visit [VSCode documentation](https://code.visualstudio.com/docs/editor/extension-gallery)\n\n## Plugin activation\n\nVSCode plugins are running in external processes (which means they should never impact editor performance) and are activated lazily, when certain activation events happens. This means that plugins are not loaded unnecesserly, for example when you don't work on project using given programming language.\n\nIonide plugins are activated when:\n\n* Opened workspace contains any `.fsproj`, `.fs`, or `.fsx` file\n\n* New `.fsproj`, `.fs`, or `.fsx` file is created in workspace that was not containing those files before.\n"},{"uri":"/Editors/Code/overview.html","title":"Overview","content":"\n# Ionide-VSCode\n\n**GitHub link:** [https://github.com/ionide/Ionide-vscode-fsharp](https://github.com/ionide/Ionide-vscode-fsharp)\n**License:** [MIT](https://github.com/ionide/Ionide-vscode-fsharp/blob/master/LICENSE.md)\n\nIonide is a [Visual Studio Code](https://code.visualstudio.com/) package suite for cross platform F# development.\n\n<img class=\"gif\" src=\"/static/images/fsharp.gif\" />\n\n## Overview\n\nIonide for VSCode is set of 3 plugins avaliable in VSCode marketplace.\n\n* [Ionide-fsharp](https://marketplace.visualstudio.com/items?itemName=Ionide.Ionide-fsharp) - provides F# specific features including advanced editor features (autocomplete, go-to definition, tooltips, rename, various refactorings and quick fix suggestions), integration with .NET project system, project explorer for project file visualization and manipulation, integration with MsBuild for building and running applications, debugger integration and more.\n\n<img class=\"gif\" src=\"/static/images/fsi.gif\" />\n\n\n* [Ionide-Paket](https://marketplace.visualstudio.com/items?itemName=Ionide.Ionide-Paket) - provides integration with Paket - package dependency manager for .NET with support for NuGet packages and GitHub repositories.\n\n<img class=\"gif\" src=\"/static/images/paket.gif\" />\n\n* [Ionide-FAKE](https://marketplace.visualstudio.com/items?itemName=Ionide.Ionide-fake) - FAKE (F# Make) is popular F# tool and DSL for build orchestration.\n\n<img class=\"gif\" src=\"/static/images/fake.gif\" />\n\n## List of features\n\n#### F# IDE\n\n* Syntax highlighting\n* Error highlighting\n* Autocomplete\n* Tooltips\n* Quick Info Toolbar\n* Usages highlighting\n* F# Interactive (REPL) panel\n* Go-to declaration\n* Finding symbols in file\n* Go-to any symbol in solution\n* Rename\n* Find usages\n* Peek View declaration\n* CodeLens feature showing type signatures\n* CodeOutline tree view\n* Listing all errors in workspace\n* Building using msbuild / xbuild\n* Integration with .NET\n* Project explorer tree view\n* Debugging\n* Record stub generation\n* Union pattern case generation\n* Integration with F# Interactive\n\n#### F# Project management\n\n* Possibility to create new empty solutions or projects based on .NET SDK Templates\n* Adding, removing, ordering files in project\n* Adding and removing project references\n\n#### Paket integration\n\n* Paket initialization\n* Adding, installing, updating packages from solution or current project (allows the choice of package version)\n* Removing packages from solution or current project\n* Converting from NuGet, simplify dependency graph, turning on auto-restore for solution.\n* Listing outdated packages\n\n#### FAKE integration\n\n* Running any build target defined in FAKE build script\n* Running default FAKE target\n\n#### MSBuild integration\n\n* Build/Clean/Rebuild the current project\n* Build/Clean/Rebuild any project in the current workspace\n\n#### And much more...\n\n"},{"uri":"/Editors/Code/building.html","title":"Building your code","content":"\n# Building your code\n\n### Smart build configurations\n\nIonide generates VSCode [Tasks](https://code.visualstudio.com/docs/editor/tasks) for building, cleaning, and re-building every project in your workspace, as well as for the entire solution (if you have one). These tasks can be used as-is, or you can easily use them as the start of your own custom configurations.\n\nTo explicitly run one of the new tasks, first select the `Tasks: Run Task` command from the Command Palette (which can be invoked by pressing `Ctrl/Cmd+Shift+P`). \n\n<img class=\"png\" src=\"/static/images/vscode-run-tasks.png\" />\n\nThen, choose the `msbuild` category:\n\n<img class=\"png\" src=\"/static/images/vscode-task-category.png\" />\n\nFinally, choose the task you want to run from the list:\n\n<img class=\"png\" src=\"/static/images/vscode-msbuild-tasks.png\" />\n\n### Defaults\n\nBy default, using `Ctrl/Cmd+Shift+B` will run the 'build' task for the current project.\n\n### Integration with debugging\n\nAll generated tasks can be used as `preLaunchTask`s for your own launch/debug configurations, which can really help for ensuring that the most recent build is always used when debugging or running your own code. See [running](/docs/running) for more information about this.\n"},{"uri":"/Editors/Code/testing.html","title":"Testing your code","content":"\n# Testing your code\n\nIonide now includes a Test Explorer to make it easier to run your tests. The explorer will discover test as your code is type-checked, and allows for running all tests, or a subset of tests.  Any error results will be show at the test location, directly in your code!\n\nYour projects will be built before running the tests to ensure the most up-to-date version is used.\n\nThe Test Explorer will detect tests for NUnit, XUnit, and Expecto currently, and requires a `dotnet test` adapter for your chosen framework be installed and configured in order to work. If you can run `dotnet test` on your tests successfully, you're all set!"},{"uri":"/Editors/Code/editing.html","title":"Editing evolved","content":"# Editing evolved\n\nIonide provides a variety of language features known from larger IDEs such as VS, and a set of innovative features that makes you more productive then ever when writing F# code like CodeLenses, integration with FSharpLint and Quick Fixes.\n\n## Basic features\n\nFollowing documentation is basic overview of features from Ionide's point of view. If you want to learn more about capabilities of VSCode visit [official documentation](https://code.visualstudio.com/docs/editor/codebasics). We strongly recommend exploring detailed VSCode documentation, especially if you've never worked with similar (Atom, ST3) editor before.\n\n### IntelliSense\n\nIf Ionide knows possible completions, the IntelliSense suggestions will pop up as you type. If you continue typing characters, the list of members (variables, methods, etc.) is filtered to include only members containing your typed characters. Pressing `Tab` or `Enter` will insert the selected member.\n\nYou can trigger IntelliSense in any editor window by typing `Ctrl+Space` or by typing a trigger character (such as the dot character (`.`)).\n\n> Tip: The suggestions widget supports CamelCase filtering meaning you can type the letters which are upper cased in a method name to limit the suggestions. For example, \"cra\" will quickly bring up \"createApplication\".\n\nAdditionally, Ionide provides autocompletion for symbols not defined in currently opened modules and namespaces. If you accept such completion with `Tab` or `Enter` it will automatically insert appropriate `open` statement. This behavior is controlled by `FSharp.externalAutocomplete` setting (default value is `true`).\n\n---\n\nAdditionally, you can see quick info for each method by either pressing `Ctrl+Space` or clicking the info icon. The accompanying documentation for the method will now expand to the side. The expanded documentation will stay so and will update as you navigate the list. You can close this by pressing `Ctrl+Space` again or by clicking on the close icon.\n\n<img class=\"gif\" src=\"/static/images/autocomplete.gif\" />\n\n### Tooltips\n\nIonide provides rich information about the symbols you hover on - structured signature and nicely formatted documentation text supporting markdown inside of the comments and transforming standard XML comment tags into markdown representation.\n\n> Tip: If you press `Ctrl` while hovering Ionide will also put the body of the symbol in the tooltip.\n\n<img class=\"gif\" src=\"/static/images/tooltips.gif\" />\n\n\n### Error highlighting\n\nIonide provides fast error highlighting for local changes, changes in current project and cross project changes without any need to build projects. Error highlighting for current projects works as you edit code, it supports files not saved to disk. For cross project error reporting you need to save the file - it will queue background project type checking which will provide errors asynchronously without blocking any editor operations.\n\nErrors in VSCode are shown in multiple places:\n\n* In the status bar, there is a summary of all errors and warnings counts.\n* You can click on the summary or press `Ctrl+Shift+M` to display the `PROBLEMS` panel with a list of all current errors.\n* If you open a file that has errors or warnings, they will be rendered inline with the text and in the overview ruler.\n\n> Tip: To loop through errors or warnings in the current file, you can press `F8` or `Shift+F8` which will show an inline zone detailing the problem and possible code actions (if available).\n\n<img class=\"gif\" src=\"/static/images/errors.gif\" />\n\n\n### CodeLens and LineLens\n\nIonide displays type signatures of the symbols either as information over the symbol (inserting virtual line) or as inlined information next to symbol. The behavior is customizable with `editor.codeLens`, `FSharp.lineLens.enabled` and `FSharp.lineLens.*` settings.\n\n### Inlay hints\n\nIonide provides Inlay Hints that call out the types of let-bindings, as well as the parameter names of method parameters.\n\n### Quick Info panel\n\nYou can check the type of symbol on which cursor currently is in the left part of VSCode Status Bar (bottom bar with different additional information about current position and file)\n\n### Generate record stubs\n\nYou can generate record stubs by using the `Quick Fix` feature (Default keyboard shortcut is `Ctrl+.`). The feature is activated in two ways:\n\n* Using a type hint ```let p : Person = { }``` with the cursor over `Person`\n* Starting to type the fields of the record\n\n<img class=\"gif\" src=\"/static/images/generateRecordStubs.gif\" />\n\n### Generate pattern matching stubs\n\nYou can generate pattern matching stubs by using the `Quick Fix` feature (Default keyboard shortcut is `Ctrl+.`).\n\n### Generate object expression implementation stub\n\nYou can generate object expression implementation stub by using the `Quick Fix` feature (Default keyboard shortcut is `Ctrl+.`).\n\n### Smart debug configurations\n\nIonide generates Debugging Launch Configurations for runnable projects in your workspace. These can be extracted at any time to be a good starting point for any customizations you'd like to make. In addition, if your projects support [launchSettings.json](https://docs.microsoft.com/aspnet/core/fundamentals/environments?view=aspnetcore-6.0#development-and-launchsettingsjson), Ionide will generate a launch configuration for each launch profile with `\"commandName\"` of `'Project'` that you have configured.  This allows you to share launch configurations across VS Code, Visual Studio, JetBrains Rider, and the dotnet CLI via the `dotnet run` command.\n\n## Code navigation\n\nVisual Studio Code has a high productivity code editor which, when combined with programming language services, gives you the power of an IDE and the speed of a text editor. In this part we will show different ways of navigating around the code.\n\n### Go to definition\n\nIonide provides going to symbol definition. You can do that by pressing `F12`, pressing right click on symbol and choosing `Go to definition` or by using `Ctrl+Click` or running `Go to definition` from Command Palette.\n\n> Tip: You can use `Ctrl+Alt+Click` or open the definition to the side in additional editor panel.\n\n### Go to type definition\n\nIonide provides going to definition of the type of current symbol if the type was defined in local workspace. You can do that by running the `Go to Type Definition` command from either the editor context menu or the Command Palette.\n\n> Tip: The command `editor.action.goToTypeDefinition` is not bound to a keyboard shortcut by default but you can add your own custom keybinding.\n\n### Go to symbol in file\n\nYou can navigate symbols inside a file with `Ctrl+Shift+O`. Just press `Up` or `Down` and navigate to the place you want.\n\n> Tip: By typing `:` the symbols will be grouped by category.\n\n### Go to symbol in workspace\n\nIonide support jumping to a symbol across files with `Ctrl+T`. Just type the first letter of a symbol you want to navigate to, regardless of which file contains it, and press `Enter`.\n\n<img class=\"gif\" src=\"/static/images/goToSymbol.gif\" />\n\n### Find all references & Peek definition\n\nIonide also implements providers for finding all references (`Shift+F12`) of the symbol in currently open solution and peeking definition of the symbol (`Alt+F12`). VSCode provides peeked editors which enables you to see the source code of the other file inlined without switching context. You can navigate between different references in the peeked editor and make quick edits right there. Clicking on the peeked editor filename or double-clicking in the result list will open the reference in the outer editor.\n\n<img class=\"gif\" src=\"/static/images/peek.gif\" />\n\n### Bracket matching\n\nMatching brackets will be highlighted as soon as the cursor is near one of them.\n\n> Tip: You can jump to the matching bracket with `Ctrl+Shift+\\`\n\n### Go to next symbol usage\n\nUsages of symbol in current file will be highlighted as soon as the cursor is on the symbol.\n\n> Tip: You can jump to the next/previous usage with `F7` and `Shift+F7`\n\n### Go to MSDN help\n\nIonide provides command for opening MSDN documentation for given symbol. It works only for symbols from F# standard library, and .NET standard library. You can execute command with `Shift+F1` or from Command Palette (`F#: Get Help`).\n\n### CodeOutline panel\n\nIonide provides live updated panel showing symbols in current file. It's available as a additional tree view (`F# Code Outline`) in VSCode Explorer panel. On the panel you can notice 2 buttons - right one collapse (`Click`) or extends (`Alt+Click`) all elements in the tree, left one refreshes default collapsing (only modules and namespaces extended, types collapsed).\n\n> Tip: Clicking on any node in the tree will move you to the place in file where symbol is defined. It's really useful for navigating around huge files.\n\n<img class=\"gif\" src=\"/static/images/codeOutline.gif\" />\n\n## Advanced analyzers\n\n### FSharpLint integration\n\nIonide incorporates the [FSharpLint](https://fsprojects.github.io/FSharpLint/) project, which allows you to run linting rules against your code and see the results in your editor.\n\n### Unused value analyzer\n\nIonide will detect unused values in your code and suggest that you remove them.\n\n### Unnecessary open statement analyzer\n\nIonide will detect namespaces and modules that you've `open`ed in your code that aren't being used, and suggest that you remove them.\n\n### Simplify name analyzer\n\nIf you've over-qualified a name, for example if you've typed `System.IO.FileInfo` when you already had `System.IO` open, Ionide will suggest a codefix that removes the unnecessary portion of the name.\n\n## Refactoring\n\n### Rename symbol\n\nIonide supports renaming of bindings, parameters, and so on.\n\n### Code Fixes\n\nIonide supports a host of code fixes. They can all be invoked by using the light bulb icon that appears when they are available.\n\n* Add an explicit type to a function parameter\n* Add a `fun` keyword to a lambda that was written without one\n* Add a missing 'self' identifier parameter to a method that needs one\n* Add a missing `rec` keyworkd to a recursive function that doesn't have one\n* Add an explicit type annotation to a parameter that throws an indeterminate type error (errors 72 or 3245)\n* Change C#-style use of `=` for assignment to `<-` instead\n* Change C#-style use of `=>` for a lambda to `->` instead\n* Change uses of `typeof<'t>.Name` to use `nameof('t)` instead\n* Change use of `=` in record field declarations to `:`\n* Change C#-style use of `!=` to `<>` instead\n* Change a record creation of an unknown type to use an anonymous record instead\n* Change a positionally-matched DU to a named-match DU instead\n* Change C#-style use of `==` for equality to `=` instead\n* Change the declaration of a let-binding to `mutable` when a user attempts to mutate it later\n* Add a missing `=` when you start a type declaration and rush past the name to the fields/union cases\n* Convert negation of a value to subtraction instead when negation was not intended\n* Suggest the use of `new` for disposable types\n* Wrap an expression in parentheses when it is necessary to resolve parameter ambiguity\n* Remove redundant qualifiers\n* Change C#-style use of `!` for negation to use `not` instead\n* Remove explicit `return` or `yield` commands inside a CE when the compiler thinks they are not necessary\n* Change use of the `!` operator on ref cells to use `.Value` instead\n* Offer to open modules/namespaces or use fully-qualified names when a type is used but the full name cannot be resolved\n* Replace a potentially-typo'ed identifier name with one from a compiler-suggested list of possibilities\n* Replace the use of unsafe downcast operations with safe casts operations when it is correct to do so\n\n### Generate XML documentation comments\n\nIonide can generate XML documentation comments that scaffold out the relevant XML structures for your current function, member or value."},{"uri":"/Editors/Code/running.html","title":"Running your code","content":"\n# Running your code\n\n### Smart launch configurations\n\nIonide generates VSCode [Launch Configurations](https://code.visualstudio.com/docs/editor/debugging#_launch-configurations) for running and debugging each runnable project in your workspace. Generally this means projects with a `ProjectType` of `Exe`. These autogenerated configurations act essentially the same as running `dotnet run` in the project's directory.\n\nIonide will generate additional launch configurations for any projects that have a [`Properties/launchSettings.json`](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/environments?view=aspnetcore-6.0#development-and-launchsettingsjson) file. This file is often generated by Visual Studio, but can be generated manually as well. These launch settings profiles can be run by Visual Studio, `dotnet run`, `dotnet watch`, and JetBrains Rider, and now VSCode joins the bunch! Any launch settings profiles with a `commandName` of `Project` can be run, and any `applicationUrl`, `environmentVariables`, and `commandLineArgs` settings will be used.\n\nThe generated launch configurations will set a `preLaunchTask` dependency on the `Build` task for their associated project, so you'll always run the most up-to-date build before running your code.\n\n### Running a launch configuration\n\nTo explicitly run one of the new launch configurations, choose the Debug menu, and select a configuration from the drop-down menu. From there, you're all set!"},{"uri":"/Editors/Code/options.html","title":"Customization","content":"\n# Customizing Ionide\n\n## Table of Contents\n\n* [How to set an option](#how-to-set-an-option)\n* [Ionide Settings](#ionide-settings)\n* [Theming](#theming)\n\n## How to set an option?\n\nIt is easy to configure Visual Studio Code to your liking through its various settings. Nearly every part of VS Code's editor, user interface, and functional behavior has options you can modify.\n\nVS Code provides two different scopes for settings:\n\n* **User Settings** - Settings that apply globally to any instance of VS Code you open.\n* **Workspace Settings** - Settings stored inside your workspace and only apply when the workspace is opened.\n\nWorkspace settings override user settings. Workspace settings are specific to a project and can be shared across developers on a project.\n\n> Note: A VS Code \"workspace\" is usually just your project root folder\n\nTo open your user and workspace settings, use the following VS Code menu command:\n\n* On Windows/Linux - `File > Preferences > Settings`\n* On macOS - `Code > Preferences > Settings`\n\nYou can also open the Settings editor from the Command Palette (`Ctrl+Shift+P`) with `Preferences: Open Settings` or use the keyboard shortcut (`Ctrl+,`).\n\nRead more about settings in VSCode in [VSCode documentation](https://code.visualstudio.com/docs/getstarted/settings)\n\n---\n\n## Ionide Settings\n\n#### `FSharp.fsac.dotnetArgs`\n\nAdditional CLI arguments that will be provided to the dotnet runtime when running FSAC. These are fully described at [the official Microsoft documentation](https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet#runtime-options), and in general relate to which runtime FSAC is run on.\n\n**Type:** `string []`\n\n**Default:** `[\"--roll-forward\", \"LatestMajor\"]` or `[]`\n\nIf FSAC is launched from a directory that has a global.json whose `sdk.version` is 6.0 or greater, or if the 6.0 SDK is installed and no global.json is present, the `--roll-forward LatestMajor` arguments will be added to ensure FSAC runs under .net 6 (required to support MSBuild correctly).\n\nOtherwise no arguments are automatically supplied by Ionide.\n\n\n---\n\n#### `FSharp.fsac.netCoreDllPath`\n\nThe path to the `fsautocomplete.dll`, useful for debugging a self-built fsac.\n\n**Type:** `string`\n\n**Default:** ` `\n\n---\n\n#### `FSharp.fsac.attachDebugger`\n\nAppends the '--attachdebugger' argument to fsac, this will allow you to attach a debugger.\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n#### `FSharp.fsac.silencedLogs`\n\nAn array of log categories for FSAC to filter out. These can be found by viewing your log output and noting the text in between the brackets in the log line. For example, in the log line `[16:07:14.626 INF] [Compiler] done compiling foo.fsx`, the category is 'Compiler'.\n\n**Type:** `string []`\n\n**Default:** `[ ]`\n\n---\n\n#### `FSharp.workspaceModePeekDeepLevel`\n\nThe deep level of directory hierarchy when searching for sln/projects\n\n**Type:** `int`\n\n**Default:** `4`\n\n---\n#### `FSharp.fsiFilePath`\n\nThe path to the F# Interactive tool used by Ionide-FSharp (.NET framework only, on .NET Core `FSharp.fsiSdkFilePath` is used)\n\n**Type:** `string`\n\n**Default:** ` `\n\n---\n#### `FSharp.fsiSdkFilePath`\n\nThe path to the F# Interactive tool used by Ionide-FSharp (when using .NET SDK scripts)\n\n**Type:** `string`\n\n**Default:** ` `\n\n---\n\n\n#### `FSharp.keywordsAutocomplete`\n\nIncludes keywords in autocomplete\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.externalAutocomplete`\n\nIncludes external (from unopened modules and namespaces) symbols in autocomplete\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n#### `FSharp.linter`\n\nEnables integration with [FSharpLint](https://fsprojects.github.io/FSharpLint/) for additional (user-defined) warnings\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.unionCaseStubGeneration`\n\nEnables a codefix that generates missing union cases when in a match expression\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.unionCaseStubGenerationBody`\n\nThe expression to fill in the right-hand side of match cases when generating missing cases for a match on a discriminated union\n\n**Type:** `string`\n\n**Default:** `failwith \\\"Not Implemented\\\"`\n\n---\n\n#### `FSharp.recordStubGeneration`\n\nEnables a codefix that will generate missing record fields when inside a record construction expression\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.recordStubGenerationBody`\n\nThe expression to fill in the right-hand side of record fields when generating missing fields for a record construction expression\n\n**Type:** `string`\n\n**Default:** `failwith \\\"Not Implemented\\\"`\n\n---\n\n#### `FSharp.interfaceStubGeneration`\n\nEnables a codefix that generates missing interface members when inside of an interface implementation expression\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.interfaceStubGenerationMethodBody`\n\nThe expression to fill in the right-hand side of interface members when generating missing members for an interface implementation expression\n\n**Type:** `string`\n\n**Default:** `failwith \\\"Not Implemented\\\"`\n\n---\n\n#### `FSharp.interfaceStubGenerationObjectIdentifier`\n\nThe name of the 'self' identifier in an interface member. For example, `this` in the expression `this.Member(x: int) = ()`\n\n**Type:** `string`\n\n**Default:** `this`\n\n---\n\n#### `FSharp.abstractClassStubGeneration`\n\nEnables a codefix that generates missing members for an abstract class when in an type inheriting from that abstract class.\n\n**Type:** `boolean`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.abstractClassStubGenerationObjectIdentifier`\n\nThe name of the 'self' identifier in an inherited member. For example, `this` in the expression `this.Member(x: int) = ()`\n\n**Type:** `string`\n\n**Default:** `this`\n\n---\n\n#### `FSharp.abstractClassStubGenerationMethodBody`\n\nThe expression to fill in the right-hand side of inherited members when generating missing members for an abstract base class\n\n**Type:** `string`\n\n**Default:** `failwith \\\"Not Implemented\\\"`\n\n---\n\n#### `FSharp.unusedOpensAnalyzer`\n\nEnables detection of unused opens\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.unusedDeclarationsAnalyzer`\n\nEnables detection of unused declarations\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.simplifyNameAnalyzer`\n\nEnables detection of cases when names of functions and values can be simplified\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.fsiExtraParameters`\n\nAn array of additional command line parameters to pass to FSI when it is started. See [the documentation](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/fsharp-interactive-options) for an exhaustive list.\n\n**Type:** `array`\n\n**Default:** `[]`\n\n---\n\n#### `FSharp.saveOnSendLastSelection`\n\nIf enabled, the current file will be saved before sending the last selection to FSI for evaluation\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n#### `FSharp.msbuildAutoshow`\n\nAutomatically shows the MSBuild output panel when MSBuild functionality is invoked\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n#### `FSharp.resolveNamespaces`\n\nEnables a codefix that will suggest namespaces or module to open when a name is not recognized\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.enableTreeView`\n\nEnables the solution explorer view of the current workspace, which shows the workspace as MSBuild sees it\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.excludeProjectDirectories`\n\nDirectories in the array are excluded from project file search. Requires restart.\n\n**Type:** `array`\n\n**Default:** `[\".git\",\"paket-files\",\".fable\",\"packages\",\"node_modules\"]`\n\n---\n\n#### `FSharp.lineLens.enabled`\n\nUsage mode for LineLens. If `never`, LineLens will never be shown.  If `replaceCodeLens`, LineLens will be placed in a decoration on top of the current line.\n\n**Type:** `enum`\n\n**Possible values:**\n * `never`\n * `replaceCodeLens`\n * `always`\n\n**Default:** `replaceCodeLens`\n\n---\n\n#### `FSharp.lineLens.prefix`\n\nThe prefix displayed before the signature in a LineLens\n\n**Type:** `string`\n\n**Default:** `//`\n\n---\n\n#### `FSharp.disableFailedProjectNotifications`\n\nDisables popup notifications for failed project loading\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n\n#### `FSharp.enableBackgroundServices`\n\nEnables background services responsible for creating symbol cache and typechecking files in the background. Requires restart.\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.enableMSBuildProjectGraph`\n\nEXPERIMENTAL. Enables support for loading workspaces with MsBuild's ProjectGraph. This can improve load times. Requires restart.\n\n**Type:** `boolean`\n\n**Default:** `false`\n\n---\n\n#### `FSharp.enableReferenceCodeLens`\n\nEnables additional code lenses showing number of references of a function or value. Requires background services to be enabled.\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.showProjectExplorerIn`\n\nSet the activity (left bar) where the project explorer view will be displayed. If `explorer`, then the project explorer will be a collapsible tab in the main explorer view, a sibling to the file system explorer. If `fsharp`, a new activity with the F# logo will be added and the project explorer will be rendered in this activity.Requires restart.\n\n**Type:** `enum`\n\n**Possible values:**\n * `explorer`\n * `fsharp`\n\n**Default:** `fsharp`\n\n---\n\n#### `FSharp.enableAnalyzers`\n\nEXPERIMENTAL. Enables F# analyzers for custom code diagnostics. Requires restart.\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n#### `FSharp.analyzersPath`\n\nDirectories in the array are used as a source of custom analyzers. Requires restart.\n\n**Type:** `array`\n\n**Default:** `[\"packages/Analyzers\", \"analyzers\"]`\n\n---\n\n#### `FSharp.workspacePath`\n\nPath to the directory or solution file that should be loaded as a workspace. If set, no workspace probing or discovery is done by Ionide at all.\n\n**Type:** `string`\n\n---\n\n#### `FSharp.showExplorerOnStartup`\n\nAutomatically shows solution explorer on plugin startup\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.enableTouchBar`\n\nEnables TouchBar integration of build/run/debug buttons\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.autoRevealInExplorer`\n\nControls whether the solution explorer should automatically reveal and select files when opening them. If `sameAsFileExplorer` is set, then the value of the `explorer.autoReveal` setting will be used instead.\n\n**Type:** `enum`\n\n**Possible values:**\n * `sameAsFileExplorer`\n * `enabled`\n * `disabled`\n\n**Default:** `sameAsFileExplorer`\n\n---\n\n#### `FSharp.smartIndent`\n\nEnables smart indent feature\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n#### `FSharp.infoPanelUpdate`\n\nControls when the info panel is updated\n\n**Type:** `enum`\n\n**Possible values:**\n * `onCursorMove`\n * `onHover`\n * `both`\n * `none`\n\n**Default:** `onCursorMove`\n\n---\n\n#### `FSharp.infoPanelReplaceHover`\n\nControls whether the info panel replaces tooltips\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n#### `FSharp.infoPanelStartLocked`\n\nControls whether the info panel should be locked at startup\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n#### `FSharp.infoPanelShowOnStartup`\n\nControls whether the info panel should be displayed at startup\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n#### `FSharp.verboseLogging`\n\nLogs additional information to F# output channel. This is equivalent to passing the `--verbose` flag to FSAC. Requires restart.\n\n**Type:** `bool`\n\n**Default:** `false`\n\n---\n\n#### `FAKE.targetsOutline`\n\nEnables the Targets Outline tree view.\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n\n#### `FAKE.showTargetsOutlineIn`\n\nSet the activity (left bar) where the FAKE targets outline view will be displayed.Requires restart.\n\n**Type:** `enum`\n\n**Possible values:**\n * `explorer`\n * `fsharp`\n\n**Default:** `explorer`\n\n---\n\n#### `FSharp.suggestGitignore`\n\nAllow Ionide to prompt whenever internal data files aren't included in your project's .gitignore\n\n**Type:** `bool`\n\n**Default:** `true`\n\n---\n#### `FSharp.suggestSdkScripts`\n\nAllow Ionide to suggest using .NET SDK FSI for scripting instead of .NET Framework FSI\n\n**Type:** `boolean`\n\n**Default:** `true`\n\n---\n#### `FSharp.useSdkScripts`\n\nUse `dotnet fsi` instead of `fsi.exe`/`fsharpi` to start an FSI session\n\n**Type:** `boolean`\n\n**Default:** `true`\n\n---\n\n#### `FSharp.dotnetRoot`\n\nSets the root path for finding locating the dotnet CLI binary. Defaults to the `dotnet` binary found on your system PATH.\n\n**Type:** `string`\n\n---\n#### `FSharp.addFsiWatcher`\n\nEnables a panel for FSI that shows the value of all existing bindings in the FSI session\n\n**Type:** `boolean`\n\n**Default:** `false`\n\n---\n#### `FSharp.generateBinLog`\n\nEnables generation of `msbuild.binlog` files for project loading. It works only for fresh, non-cached project loading. Run `F#: Clear Project Cache` and reload window to force fresh loading of all projects. These files can be loaded and inspected using the [MSBuild Structured Logger](https://github.com/KirillOsenkov/MSBuildStructuredLog)\n\n**Type:** `boolean`\n\n**Default:** `false`\n\n---\n#### `FSharp.pipelineHints.enabled`\n\nEnables pipeline hints, which are like LineLenses that appear along each step of a chain of piped expressions\n\n**Type:** `boolean`\n\n**Default:** `true`\n\n---\n#### `FSharp.pipelineHints.prefix`\n\nThe prefix displayed before the signature of a pipeline hint\n\n**Type:** `string`\n\n**Default:** `  // `\n\n---\n\n#### `FSharp.inlayHints.enabled`\n\nControls if the inlay hints feature is enabled.\n\n**Type:** `boolean`\n\n**Default:** `true`\n\n#### `Fsharp.inlayHints.parameterNames`\n\nControls if parmaeter-name inlay hints will be displayed for functions and methods.\n\n**Type:** `boolean`\n\n**Default:** `true`\n\n#### `FSharp.inlayHints.typeAnnotations`\n\nControls if type-annotation inlay hitns will be displayed for bindings.\n\n**Type:** `boolean`\n\n**Default:** `true`\n\n## Theming\n\nVS Code allows for very deep theming and customization, and Ionide plugs into this system excellently.\nThe Language Server performs advanced syntax highlighting and annotates the source code with [semantic tokens and modifiers](https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#standard-token-types-and-modifiers).\nThese tokens and modifiers can be themed individually in whatever way you want. For a deep dive on semantic tokens, including how\nto find out which tokens and modifiers have been applied to source code that you want to theme, please see the [official documentation](https://code.visualstudio.com/docs/getstarted/themes#_editor-semantic-highlighting).\n\nIn addition to the standard set of tokens and modifiers shown on that documentation, Ionide provides several custom scopes and modifiers:\n\n#### Scopes\n\n* `member`- used in mutable vars and record fields, as well as exceptions, fields, events, delegates, and named arguments\n* `cexpr` - for computation expressions\n* `text` - for plaintext strings\n\n#### Modifiers\n\n* `mutable` - for any values that are defined as `let mutable`\n* `disposable` - for any values that implement `System.IDisposable`\n\n\n### Applying custom themes\n\nLike all settings, theme customizations are stored in settings files, which are described at the top of this page in greater detail.\n\nSemantic tokens can be overidden on a theme-by-theme basis in the following way:\n\n\n```js\n{\n    \"editor.semanticTokenColorCustomizations\": {\n      \"[Default Dark+]\": {\n            \"enabled\": true,\n            \"rules\": {\n                \"*.mutable\": {\n                    \"foreground\": \"#FF0000\",\n                    \"fontStyle\": \"underline\",\n                },\n                \"*.disposable\": {\n                    \"foreground\": \"#ff8b2c\",\n                    \"fontStyle\": \"bold\"\n                }\n\n            }\n        }\n    }\n}\n```\n\nA few things to note about this example:\n\n* the individual theme names are placed into square brackets\n* the `rules` are a map of `scope` or `modifier` to the theme settings to be applied to tokens that match\n* the key of a `rule` can be\n  * a fully-qualified scope (i.e. `<scope>.<modifier>`, for example `member.mutable`)\n  * just a scope (i.e. `member`)\n  * a wildcard modifier (i.e. `*.mutable` to apply to all mutables, regardless of scope)\n"},{"uri":"/Editors/Code/generalInfo.html","title":"General information","content":"\n# General information\n\nIonide is complex tool with many options, and powerful capabilities, supporting multiple scenarios available to F# developers. As such is crucial to learn some general information about Ionide's requirements, and different configuration options that should be used depending on the different runtime and environments that can be used.\n\n### Project files parsing\n\nIonide supports SDK-based project files and solutions only. When you open VSCode in particular workspace, Ionide will try to find all `.sln` files in this workspace, and you will be presented with the option to open particular solution or ignore solution files and load all projects in the solution.\n\n<img class=\"gif\" src=\"/static/images/chooseSolution.png\" />\n\nWhen Ionide detects any F# projects it will display them in the `Solution Explorer`. To access it you need to press F# logo button on the activity bar. In there you will see list of F# projects, their status, list of file and references. You can also right-click on different nodes in the tree to access operations that can be performed by the Ionide, such as `Build Project` or `Add file`.\n\n<img class=\"gif\" src=\"/static/images/projectExplorer.png\" />\n\n> NOTE: In case of the problems with project parsing (Projects in status `loading failed`) you can right-click on the project node and use `Show Project Status` to see more details about the problem. We also recommend using `F#: Clear Cache` action and reloading the window, as first step in debugging any problems.\n\n### FsAutoComplete Service Runtime\n\nThe Ionide plugin relies on the F# compiler services for processing code in the editor. This requires the .NET SDK version 6.0.100 or greater to be installed on your machine.\n\n### MsBuild Host\n\nThe Ionide plugin provides deep integration with MSBuild - starting from project parsing (process of getting list of files, references and properties out of `fsproj` file) through project modifications (adding new files, ordering them, adding project-to-project references) to building and running projects. All features provided by Ionide in area of project management are described more in the [Project](project) section.\n\nIonide uses the cross platform version of MsBuild provided by the installed .NET SDK.\n"}]